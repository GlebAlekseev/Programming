#include <iostream>
#include <vector>
#include <ctime>
#include <fstream>
using namespace std;
ostream& operator<< (ostream& out, const vector<int> item) {

	//Отправлять в поток размер вектора, табуляцию, символ | и пробел;
	out << item.size() << '\t' << item.capacity() << '\t' << "| ";
	for (int i = 0; i < item.size(); i++)
	{
		out << &item[i] << " ";
	}
	return out;
}
int main()
{
	srand(time(NULL));
	vector<int> myitems;
	ofstream src("data.txt");

	for (int i = 0; i < 64; i++)
	{
		myitems.push_back(rand()%100);
		src << myitems << endl;
	}

	for (int i = myitems.size()-1; i > 0; i--)
	{
		myitems.pop_back();
		src << myitems << endl;
	}






}
//  Вопрос 1. Попытайтесь объяснить увиденную закономерность. data_1.txt

//  Для наглядности я добавил рядом с size, capacity - выдает под сколько элементов выделена память
//	Когда размер вектора превышает выделенный под него размер, под вектор заного выделяется память но уже на 50% больше элементов чем было до этого
//	Из файла видно:
//			1 элемент,  +1 станет 50% от 1 = 1+0.5 = 2
//			2 элемента, +1 станет 50% от 2 = 2+1 = 3
//			3 элемента, +1 станет 50% от 3 = 3+1.5 = 4
//			4 элемента, +1 станет 50% от 4 = 4+2 = 6
//			6 элемента, +1 станет 50% от 6 = 6+3 = 9
//			9 элемента, +1 станет 50% от 9 = 9+4.5 = 13
//			13 элемента, +1 станет 50% от 13 = 13+6 = 19
//			19 элемента, +1 станет 50% от 19 = 19+9.5 = 28
//			28 элемента, +1 станет 50% от 28 = 28+14 = 42
//			42 элемента, +1 станет 50% от 42 = 42+21 = 63
//			63 элемента, +1 станет 50% от 63 = 63+31.5 = 94
//			... при получении 50%
//  В моменты когда имеется запас выделенной памяти под вектор, адрес памяти не изменяется

//  Вопрос 2. Если запомнить адрес нулевой ячейки вектора при его длине 15 элементов, а затем внести изменения по запомненному адресу при длине вектора 25 элементов. 
//  Изменится ли значение нулевой ячейки вектора? Объяснить почему. 

//  Исходя из ответа на вопрос 1
//  В момент длины вектора 15 элементов, выделенной памяти хватит на 19 элементов
//  В момент длины вектора 25 элементов, не входит в диапазон 19 элементов, а значит адрес сменится, исходя из этого значение нулевой ячейки вектора не изменится.


//  Вопрос 3. Попытайтесь объяснить увиденную закономерность. data_2.txt

//  При уменьшении вектора память освобождаться не будет, поэтому (новая память не выделяется) адреса остаются прежними.

//  Вопрос 4. Есть ли отличия от результатов полученных во 2й части задания? Объяснить почему. data_3.txt
//  Отличия во второй части полученных результатов связаны с тем, что в момент удаления элемента память освобождается capacity вектора уменьшается с каждым удалением.